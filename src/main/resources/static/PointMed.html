<!DOCTYPE html>
<html lang="en">
<head>
    <title>Draw elements</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #cccccc;
            font-family:Monospace;
            font-size:13px;
            text-align:center;

            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px; width: 100%;
            padding: 5px;
        }

        a {
            color: #0080ff;
        }

    </style>
</head>
<body>

<form method="POST" action="/upload" id="data" enctype="multipart/form-data">
    <input type="file" id="InputFile" name="file" style="visibility:hidden">
    <input type="submit" id="submit" value="Upload" style="visibility:hidden">
</form>

<!--<input id="InputFile" type="file" style="visibility:hidden" />-->


<script type="x-shader/x-vertex" id="vertexshader">
    attribute float size;
    attribute float alpha;
    varying float vAlpha;

    attribute vec3 customColor;
    varying vec3 vColor;
    void main() {
        vAlpha = alpha;
        vColor = customColor;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_PointSize = size * ( 300.0 / -mvPosition.z );
        gl_Position = projectionMatrix * mvPosition;
    }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    varying float vAlpha;
    uniform vec3 color;
    uniform sampler2D texture;
    varying vec3 vColor;
    void main() {
        vec4 outColor = texture2D( texture, gl_PointCoord );

        if ( outColor.a < 0.5) discard;

        gl_FragColor = outColor * vec4( color * vColor, 1 );
        gl_FragColor.a = vAlpha;
    }
</script>


<div id="container"></div>

<script src="JsLib/dat.gui.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="JsLib/three.js"></script>
<script src="JsLib/OrbitControls.js"></script>
<script src="JsLib/stats.min.js"></script>

<script>


    var palette = [
        new THREE.Color("rgb(255,176,46)"),
        new THREE.Color("rgb(205,127,50)"),
        new THREE.Color("rgb(144,0,32)"),
        new THREE.Color("rgb(69,22,28)"),
        new THREE.Color("rgb(52,59,41)"),

        new THREE.Color("rgb(213,113,63)"),
        new THREE.Color("rgb(100,149,237)"),
        new THREE.Color("rgb(154,206,235)"),
        new THREE.Color("rgb(218,216,113)"),
        new THREE.Color("rgb(52,201,36)"),

        new THREE.Color("rgb(222,76,138)"),
        new THREE.Color("rgb(0,255,127)"),
        new THREE.Color("rgb(236,234,190)"),
        new THREE.Color("rgb(167,252,0)"),
        new THREE.Color("rgb(189,51,164)"),

        new THREE.Color("rgb(112,41,99)"),
        new THREE.Color("rgb(94,33,41)"),
        new THREE.Color("rgb(65,72,51)"),
        new THREE.Color("rgb(145,30,66)"),
        new THREE.Color("rgb(37,109,123)"),


        new THREE.Color("rgb(0,149,182)"),
        new THREE.Color("rgb(255,207,72)"),
        new THREE.Color("rgb(204,85,0)"),
        new THREE.Color("rgb(184,183,153)"),
        new THREE.Color("rgb(220,220,220)"),


        new THREE.Color("rgb(223,115,255)"),
        new THREE.Color("rgb(243,165,5)"),
        new THREE.Color("rgb(115,66,34)"),
        new THREE.Color("rgb(201,160,220)"),
        new THREE.Color("rgb(193,84,193)"),

        new THREE.Color("rgb(66,94,23)"),
        new THREE.Color("rgb(181,121,0)"),
        new THREE.Color("rgb(0,84,31)"),
        new THREE.Color("rgb(89,51,21)"),
        new THREE.Color("rgb(202,55,103)"),

        new THREE.Color("rgb(21,96,189)"),
        new THREE.Color("rgb(255,67,164)"),
        new THREE.Color("rgb(252,108,133)"),
        new THREE.Color("rgb(162,173,208)"),
        new THREE.Color("rgb(245,245,245)"),


        new THREE.Color("rgb(244,169,0)"),
        new THREE.Color("rgb(253,188,180)"),
        new THREE.Color("rgb(237,255,33)"),
        new THREE.Color("rgb(225,204,79)"),
        new THREE.Color("rgb(154,205,50)"),
        new THREE.Color("rgb(197,227,132)"),
    ];


    var gui;

    var group;
    var container, controls, stats;
    var particlesData = [];
    var camera, scene, renderer;
    var positions, colorsLine, colorsPoints, alphaPoint;
    var particles;
    var pointCloud;
    var particlePositions;
    var particleSize;
    var linesMesh;

    var mapMesh = {};
    var previousValue;

    var maxParticleCount = 1000;


    var opacityColor = 1;
    var maxOpacity = 1;
    var particleCount = 500;
    var r = 800;
    var rHalf = r / 2;

    var filesName = getFilesName();

    var effectController = {
        showDots: true,
        showLines: true,
        maxOpacity: 1,
        minDistance: 150,
        limitConnections: false,
        maxConnections: 20,
        particleCount: 500,
        fileNameList:filesName,
        template: [],
        fileName : "Name",
        add:function(){ console.log("clicked")},
        loadFile:function(){
            var inputFile = document.getElementById('InputFile');
            var submit = document.getElementById('submit');
            var data = $("form#data");
            data.submit(function () {

                var formData = new FormData($(this)[0]);

                $.ajax({
                    url: "/upload",
                    type: 'POST',
                    data: formData,
                    async: false,
                    success: function (data) {
//                        alert(data)
                    },
                    cache: false,
                    contentType: false,
                    processData: false
                });

                return false;
            });
            inputFile.addEventListener('change', function() {
                var file = inputFile.files[0];
                effectController['fileName'] = file.name;
                // update all controllers

                for (var i in gui.__controllers) {
                    gui.__controllers[i].updateDisplay();
                }
//                upload(file);
                submit.click();
            });
            inputFile.click();
        }
    };

    initGUI();
    init();

    function initGUI() {

        gui = new dat.GUI();

        gui.add( effectController, "showDots" ).onChange( function( value ) {

            for (var key in mapMesh) {
                if(previousValue==key)
                    continue;
                var meshArray = mapMesh[key];
                meshArray[0].visible = value;
            }
        } );
        gui.add( effectController, "showLines" ).onChange( function( value ) {
            for (var key in mapMesh) {
//                if(previousValue==key)
//                    continue;
                var meshArray = mapMesh[key];
                meshArray[1].visible = value;
                meshArray[2].visible = value;
            }
        } );
//        gui.add( effectController, "minDistance", 10, 300 );
//        gui.add( effectController, "limitConnections" );
//        gui.add( effectController, "maxConnections", 0, 30, 1 );

        gui.add( effectController, 'fileName');
        gui.add( effectController, 'loadFile'). name('Load CSV file');

//        gui.add( effectController, "particleCount", 0, maxParticleCount, 1 ).onChange( function( value ) {
//            particleCount = parseInt( value );
//            particles.setDrawRange( 0, particleCount );
//        });
        gui.add( effectController, "maxOpacity", 0, maxOpacity, 0.05 ).onChange( function( value ) {
            opacityColor = parseFloat( value );
            for (var key in mapMesh) {
                if(previousValue==key)
                    continue;
                var meshArray = mapMesh[key];
                updateAlpha(meshArray, opacityColor);
            }
        });

        gui.add( effectController, 'fileNameList', effectController.fileNameList).onChange(function (value) {
            scene.remove(group);
            group = new THREE.Group();
            mapMesh = {};
            var data = getData(value);
            initAll(data);
            animate();
            scene.add( group );

            var keys = Object.keys(data);
            keys.push("All");

            effectController['template'] = keys;
            // update all controllers

//            updateDisplay(gui);

            gui.__controllers[6].remove();
            gui.add( effectController, 'template', effectController.template).onChange(onChangeList); // controller 1
        });

        gui.add( effectController, 'template', effectController.template).onChange(onChangeList); // controller 1
    }


    function initAll(allObject) {
        var indexColor = 0;
        for (var key1 in allObject) {
            initModel(allObject[key1], key1, palette[indexColor]);
            indexColor++;
        }
    }

    function initModel(obj, modelName, color) {


        maxParticleCount = obj.points.length;

        var segments = maxParticleCount * maxParticleCount;

        positions = new Float32Array( segments * 3 );
        colorsLine = new Float32Array( segments * 3 );

        particlePositions = new Float32Array( maxParticleCount * 3);
        colorsPoints = new Float32Array( maxParticleCount * 3 );
        particleSize = new Float32Array( maxParticleCount);
        alphaPoint = new Float32Array( maxParticleCount);

        var opacity = effectController.maxOpacity;



        var texture = new THREE.TextureLoader().load( "../content/ball.png" );
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        var pMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                amplitude: { value: 1.0 },
                color:     { value: new THREE.Color( 0xffffff ) },
                texture:   { value: texture}
            },
            vertexShader:   document.getElementById( 'vertexshader' ).textContent,
            fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
            transparent:    true,
            depthTest:      true,
            depthWrite:     true, // changed <==========================================
//            renderDepth: 100
        });

        particles = new THREE.BufferGeometry();
//        particles.sortParticles = true;

        var colorpos = 0;
        var vertexpos = 0;
        var points = [];

        for ( var i = 0; i < maxParticleCount; i++ ) {

            var x = obj.points[i].x;
            var y = obj.points[i].y;
            var z = obj.points[i].z;

            particlePositions[ i * 3     ] = x;
            particlePositions[ i * 3 + 1 ] = y;
            particlePositions[ i * 3 + 2 ] = z;

            colorsPoints[i * 3     ] = color.r;
            colorsPoints[i * 3 + 1 ] = color.g;
            colorsPoints[i * 3 + 2 ] = color.b;

            alphaPoint[ i ] = opacity;
            particleSize[i] = obj.points[i].r*10;


            points.push(new THREE.Vector3(x, y, z));

            if(i==0){
                continue;
            }



            positions[ vertexpos++ ] = particlePositions[ i * 3     ];
            positions[ vertexpos++ ] = particlePositions[ i * 3 + 1 ];
            positions[ vertexpos++ ] = particlePositions[ i * 3 + 2 ];

            positions[ vertexpos++ ] = particlePositions[ (i-1) * 3     ];
            positions[ vertexpos++ ] = particlePositions[ (i-1) * 3 + 1 ];
            positions[ vertexpos++ ] = particlePositions[ (i-1) * 3 + 2 ];



            colorsLine[ colorpos++ ] = color.r;
            colorsLine[ colorpos++ ] = color.g;
            colorsLine[ colorpos++ ] = color.b;

            colorsLine[ colorpos++ ] = color.r;
            colorsLine[ colorpos++ ] = color.g;
            colorsLine[ colorpos++ ] = color.b;

        }

        particles.setDrawRange( 0, maxParticleCount );
        particles.addAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setDynamic( true ) );
        particles.addAttribute( 'customColor', new THREE.BufferAttribute( colorsPoints, 3 ) );
        particles.addAttribute( 'size', new THREE.BufferAttribute( particleSize, 1 ).setDynamic( true ) );
        particles.addAttribute( 'alpha', new THREE.BufferAttribute( alphaPoint, 1 ).setDynamic( true ) );

        // create the particle system
        pointCloud = new THREE.Points( particles, pMaterial );
        group.add( pointCloud );

        var geometry = new THREE.BufferGeometry();

        var spline = new THREE.CatmullRomCurve3(points);
        var splinePoints = spline.getPoints(points.length*5);

        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setDynamic( true ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colorsLine, 3 ).setDynamic( true ) );

        geometry.computeBoundingSphere();

        geometry.setDrawRange( 0, 0 );

        var material = new THREE.LineBasicMaterial( {
            vertexColors: THREE.VertexColors,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity : opacity,
        } );

        linesMesh = new THREE.LineSegments( geometry, material );

        linesMesh.geometry.setDrawRange( 0, maxParticleCount * 2 );
//        group.add( linesMesh );



        var material = new THREE.LineBasicMaterial({
            color: color,
            opacity: opacity,
            transparent: true,
        });

        var geometry = new THREE.Geometry();

        for(var i = 0; i < splinePoints.length; i++){
            geometry.vertices.push(splinePoints[i]);
        }

        var line = new THREE.Line(geometry, material);
        group.add(line);

        mapMesh[modelName] = [pointCloud, linesMesh, line];
    }

    function init() {

        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 4000 );
        camera.position.z = 50;
        controls = new THREE.OrbitControls( camera, container, container);
        scene = new THREE.Scene();


        group = new THREE.Group();
        scene.add( group );

        var helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r ) ) );
        helper.material.color.setHex( 0x080808 );
        helper.material.blending = THREE.AdditiveBlending;
        helper.material.transparent = true;
        group.add( helper );

        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true} );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );

        renderer.gammaInput = true;
        renderer.gammaOutput = true;
//        renderer.sortObjects = true;

        container.appendChild( renderer.domElement );

        stats = new Stats();
        container.appendChild( stats.dom );

        window.addEventListener( 'resize', onWindowResize, false );
    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {
        requestAnimationFrame( animate );
        stats.update();
        render();

    }

    function render() {
        renderer.render( scene, camera );
    }

    function getData(value) {
        var jsonDataR;
        $.ajax({
            dataType: 'json',
            async: false,
            url: '/getPoints/'+value,
            success: function(jsondata){
                console.log("Data was received");
                console.log(Object.keys(jsondata));
                jsonDataR = jsondata;
            }
        });
        return jsonDataR;
    }

    function updateAlpha(model, value) {
        var points = model[0].geometry.attributes.alpha;
        for( var i = 0; i < points.array.length; i++ ) {
            points.array[ i ] = value;
        }
        points.needsUpdate = true;
        model[1].material.opacity = value;
        model[1].material.needsUpdate = true;

        model[2].material.opacity = value;
        model[2].material.needsUpdate = true;
    }

    function getFilesName() {
        var jsonDataR;
        $.ajax({
            dataType: 'json',
            async: false,
            url: '/getFiles',
            success: function(jsondata){
                jsonDataR = jsondata;
            }
        });
        return jsonDataR;
    }

    var onChangeList = function( value ) {
        if(previousValue==="All"){
            for (var key in mapMesh) {
                var meshArray = mapMesh[key];
                updateAlpha(meshArray, effectController.maxOpacity);
            }
            previousValue=null;
        }
        if(value==="All"){
            for (var key in mapMesh) {
                var meshArray = mapMesh[key];
                updateAlpha(meshArray, 1);
            }
        }
        else{
            var meshArray = mapMesh[value];
            if(effectController.showDots==false){
                meshArray[0].visible = true;
            }
            updateAlpha(meshArray, 1);
            if(previousValue!=null){
                var meshArrayPrev = mapMesh[previousValue];
                if(effectController.showDots==false){
                    meshArrayPrev[0].visible = false;
                }
                updateAlpha(meshArrayPrev, effectController.maxOpacity);
            }
        }
        previousValue = value;
    }
</script>



</body>
</html>